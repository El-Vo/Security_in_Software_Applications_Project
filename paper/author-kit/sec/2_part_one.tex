\section{Part 1: Taxpayer marriage}
\label{sec:2_part_one}

Part one of the assignment deals with the marriage of tax-paying individuals. By default, every \texttt{Taxpayer} has access to the two functions \texttt{marry()} and \texttt{divorce()}. They track their marriage state using a boolean value \texttt{isMarried} and the address variable \texttt{spouse}, which points to the address of their spouse \texttt{Taxpayer} contract on the blockchain. In its initial form, \texttt{marry()} sets \texttt{isMarried = true} and records whichever address was given as the spousal address. \texttt{divorce()} does the opposite: it sets \texttt{isMarried = false} and the \texttt{spouse} address to the empty \texttt{address(0)}.

%-------------------------------------------------------------------------
\subsection{Invariants}

For the purposes of this exercise, only monogamous marriages are allowed between valid \texttt{Taxpayers}. The goal is to make sure that marriages are correctly assigned to each spouse. For this reason, three invariants were defined. The first invariant is shown in Listing \ref{lst:state-consistency}. It allows Echidna to assert that no taxpayer is allowed to marry itself after any given transaction.

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[ language=Solidity, firstline=23, lastline=25, caption={Invariant to ensure state-consistency in Taxpayer.sol}, label={lst:state-consistency} ]{../../echidna.sol}
\end{minipage}

The second invariant is shown in Listing \ref{lst:state-consistency}. It checks that the marriage-related variables \texttt{isMarried} and \texttt{spouse} are always set in conjunction to each other. It highlights problems where a \texttt{Taxpayer} could be in the state "married" (\texttt{isMarried = true}) while the \texttt{spouse} address could be set to the zero-address (\texttt{spouse = address(0)}).

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[ language=Solidity, firstline=31, lastline=43, caption={Invariant to ensure marriage-symmetry in Taxpayer.sol}, label={lst:marriage-symmetry} ]{../../echidna.sol}
\end{minipage}

The third invariant (as shown in Listing \ref{lst:marriage-symmetry}) checks the condition that two married taxpayers have to be correctly assigned to each other. Therefore, it returns \texttt{false} if any spouse is set to \texttt{isMarried = false} or the addresses of their respective \texttt{spouse} variables do not point to each of the \texttt{Taxpayer} contracts representing them.

To increase code coverage by Echidna, an additional \texttt{Taxpayer} object is created in the constructor. Without the creation of another \texttt{Taxpayer} as a helper, it would not be possible for Echidna to trigger a successful marriage between two \texttt{Taxpayers} due to only one existing in the system. Furthermore, a helper function was added to marry the two respective \texttt{Taxpayer} objects more easily. Otherwise, Echidna would need to guess the exact address of the second \texttt{Taxpayer} object, which is mathematically very unlikely.

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[ language=Solidity, firstline=63, lastline=66, caption={Helper functions for simulating the marriage logic in echidna.sol}, label={lst:marriage-helper} ]{../../echidna.sol}
\end{minipage}

%-------------------------------------------------------------------------
\subsection{Code improvements}

While invariants defined as functions allow Echidna to highlight flaws in the programming logic, they can only be fixed by manipulating the original code. First, a modifier was added to \texttt{Taxpayer.sol} which checks the validity of a proposed spouse address. When the \texttt{marry()} function is called, it executes the \texttt{isValidSpouseAddress()} validation first.

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[ language=Solidity, firstline=190, lastline=201, caption={Validation of proposed spouse addresses}, label={lst:address-validation} ]{../../Taxpayer.sol}
\end{minipage}

The validation function in Listing \ref{lst:address-validation} filters numerous reserved addresses (0--9) as well as the taxpayer's own address. Furthermore, it checks the code length of a given address. This enables it to exclude addresses that do not contain a contract. Lastly, it attempts to cast the address into a \texttt{Taxpayer} object and calls the \texttt{isContract()} function. If all checks pass, the address is successfully identified as another \texttt{Taxpayer} object.

\noindent
\begin{minipage}{\linewidth}
  \lstinputlisting[ language=Solidity, firstline=62, lastline=72, caption={Marriage function in Taxpayer.sol}, label={lst:marriage} ]{../../Taxpayer.sol}
\end{minipage}

The marriage function (shown in Listing \ref{lst:marriage}) was extended to prevent the marriage of two taxpayers where either one is already married. Additionally, a recursion logic has been implemented so that the spouse sets its marriage status according to the calling \texttt{Taxpayer} object. The \texttt{divorce()} function is structured similarly, triggering a reset of the marriage status for both spouses.

At the end of this chapter, some considerations for further development are provided that were deemed out-of-scope for the task at hand. Currently, the functions \texttt{marry()} and \texttt{divorce()} are publicly accessible and can therefore be called by anyone with the address of the \texttt{Taxpayer} contract. In a real application, it would be more secure to only allow access to these functions by the owner of the smart contract. Secondly, it is currently not prohibited to marry one's own parents, provided that they are not married to each other.