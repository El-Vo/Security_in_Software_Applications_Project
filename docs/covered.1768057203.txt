/src/Lottery.sol
  1 |     | pragma solidity ^0.8.22;
  2 |     | // SPDX-License-Identifier: UNLICENSED
  3 |     | import "Taxpayer.sol";
  4 |     | 
  5 | *   | contract Lottery {
  6 |     |     enum Phase { NotStarted, Commitment, Reveal, Endable }
  7 |     | 
  8 |     |     address owner;
  9 |     |     uint256 public round;
 10 |     |     mapping(address => uint256) public participantRound;
 11 |     |     mapping(address => bytes32) commits;
 12 |     |     mapping(address => uint) reveals;
 13 |     |     address[] revealed;
 14 |     | 
 15 |     |     uint256 public startTime;
 16 |     |     uint256 public revealTime;
 17 |     |     uint256 public endTime;
 18 |     |     uint256 public period;
 19 | *   |     bool public isContract = true;
 20 |     | 
 21 |     |     /// @notice Initializes the registry with the lottery period.
 22 |     |     /// @param p The duration of each phase in seconds.
 23 | *   |     constructor(uint p) {
 24 | *   |         period = p;
 25 | *   |         startTime = 0;
 26 | *   |         endTime = 0;
 27 | *   |         round = 0;
 28 |     |     }
 29 |     | 
 30 |     |     /// @notice Starts a new lottery round. Only possible if no lottery is currently active.
 31 | *   |     function startLottery() public {
 32 | *   |         require(startTime == 0);
 33 | *   |         round++;
 34 | *   |         startTime = block.timestamp;
 35 | *   |         revealTime = startTime + period;
 36 | *   |         endTime = revealTime + period;
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Commits a hidden value for the current lottery round.
 40 |     |     /// @param y The keccak256 hash of the chosen secret.
 41 | *   |     function commit(bytes32 y) public {
 42 | *   |         require(startTime > 0 && block.timestamp < revealTime, "Commitment phase ended or not started");
 43 | *   |         require(participantRound[msg.sender] < round, "Already committed in this round");
 44 |     |         
 45 | *   |         participantRound[msg.sender] = round;
 46 | *   |         commits[msg.sender] = y;
 47 |     |     }
 48 |     | 
 49 |     |     /// @notice Reveals the secret value to participate in the drawing.
 50 |     |     /// @param rev The secret value that was hashed during the commitment phase.
 51 | *   |     function reveal(uint256 rev) public {
 52 | *   |         require(block.timestamp >= revealTime);
 53 | *   |         require(keccak256(abi.encode(rev)) == commits[msg.sender]);
 54 |     |         
 55 | *   |         for (uint i = 0; i < revealed.length; i++) {
 56 | *   |             require(revealed[i] != msg.sender, "Already revealed");
 57 |     |         }
 58 |     | 
 59 | *   |         revealed.push(msg.sender);
 60 | *   |         reveals[msg.sender] = uint(rev);
 61 |     |     }
 62 |     | 
 63 |     |     /// @notice Ends the lottery and notifies the winner's Taxpayer contract.
 64 |     |     /// @dev Resets the state regardless of whether a winner was found.
 65 | *   |     function endLottery() public {
 66 | *   |         require(block.timestamp >= endTime);
 67 |     |         
 68 | *   |         if (revealed.length > 0) {
 69 | *   |             uint total = 0;
 70 | *   |             for (uint i = 0; i < revealed.length; i++) {
 71 | *   |                 total += reveals[revealed[i]];
 72 |     |             }
 73 |     |             
 74 | *   |             Taxpayer(revealed[total % revealed.length]).setWonLottery();
 75 |     |         }
 76 |     |         
 77 |     |         // Always reset state for the next lottery round
 78 | *   |         startTime = 0;
 79 | *   |         revealTime = 0;
 80 | *   |         endTime = 0;
 81 | *   |         delete revealed;
 82 |     |     }
 83 |     | 
 84 |     |     /// @notice Returns the list of addresses that successfully revealed their secret.
 85 |     |     function getRevealedParticipants() public view returns (address[] memory) {
 86 |     |         return revealed;
 87 |     |     }
 88 |     | }
 89 |     | 

/src/Taxpayer.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.22;
   3 |     | 
   4 |     | import "./Lottery.sol";
   5 |     | 
   6 | *   | contract Taxpayer {
   7 | *   |     uint public age;
   8 |     | 
   9 |     |     bool isMarried;
  10 |     | 
  11 | *   |     bool public isContract = true;
  12 |     | 
  13 |     |     /* Reference to spouse if person is married, address(0) otherwise */
  14 |     |     address spouse;
  15 |     | 
  16 |     |     address parent1;
  17 |     |     address parent2;
  18 |     | 
  19 |     |     /* Constant default income tax allowance */
  20 | *   |     uint constant DEFAULT_ALLOWANCE = 5000;
  21 |     | 
  22 |     |     /* Constant income tax allowance for Older Taxpayers over 65 */
  23 | *   |     uint constant ALLOWANCE_OAP = 7000;
  24 |     | 
  25 |     |     /* Income tax allowance */
  26 |     |     uint taxAllowance;
  27 |     | 
  28 |     |     uint income;
  29 |     | 
  30 | *   |     uint256 public rev;
  31 |     | 
  32 |     |     mapping(address => bool) public authorizedLotteries;
  33 |     | 
  34 |     |     bool extendedTaxAllowance;
  35 |     | 
  36 | *   |     uint256 public lotteryWins;
  37 |     | 
  38 | *   |     address constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;
  39 |     | 
  40 |     |     modifier onlyValidAddress(address _addr) {
  41 | *   |         require(
  42 | *   |             isValidSpouseAddress(_addr),
  43 |     |             "Invalid or restricted spouse address"
  44 |     |         );
  45 | *   |         _;
  46 |     |     }
  47 |     | 
  48 |     |     //Parents are taxpayers
  49 | *   |     constructor(address p1, address p2) {
  50 | *   |         age = 0;
  51 | *   |         isMarried = false;
  52 | *   |         parent1 = p1;
  53 | *   |         parent2 = p2;
  54 | *   |         spouse = address(0);
  55 | *   |         income = 0;
  56 | *   |         taxAllowance = DEFAULT_ALLOWANCE;
  57 | *   |         extendedTaxAllowance = false;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Establishes a symmetrical marriage with another taxpayer.
  62 |     |      * Uses a reciprocal call to ensure both contracts reflect the marriage.
  63 |     |      * @param newSpouse The address of the spouse's Taxpayer contract.
  64 |     |      */
  65 | *   |     function marry(address newSpouse) public onlyValidAddress(newSpouse) {
  66 | *   |         if (isMarried && spouse == newSpouse) return;
  67 | *   |         require(!isMarried, "Taxpayer is already married");
  68 |     | 
  69 | *   |         Taxpayer sp = Taxpayer(newSpouse);
  70 | *   |         require(
  71 | *   |             !sp.isMarriedState() || sp.spouseAddress() == address(this),
  72 |     |             "Partner unavailable"
  73 |     |         );
  74 |     | 
  75 | *   |         spouse = newSpouse;
  76 | *   |         isMarried = true;
  77 | *   |         sp.marry(address(this));
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Dissolves the marriage symmetrically.
  82 |     |      * Resets local state first and then triggers divorce in the spouse's contract.
  83 |     |      */
  84 | *   |     function divorce() public {
  85 | *   |         if (!isMarried) return;
  86 |     | 
  87 | *   |         address oldSpouseAddress = spouse;
  88 | *   |         spouse = address(0);
  89 | *   |         isMarried = false;
  90 |     | 
  91 |     |         // Set the default tax allowance again with respect to if the taxpayer has won the lottery or is over 64 years old.
  92 | *   |         if (hasExtendedTaxAllowance()) {
  93 | *   |             setTaxAllowance(ALLOWANCE_OAP);
  94 |     |         } else {
  95 | *   |             setTaxAllowance(DEFAULT_ALLOWANCE);
  96 |     |         }
  97 |     | 
  98 | *   |         Taxpayer(oldSpouseAddress).divorce();
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Transfers a portion of the tax allowance to the spouse.
 103 |     |      * Ensures that the deduction and addition are balanced and only possible while married.
 104 |     |      * @param change The amount of allowance to transfer.
 105 |     |      */
 106 | *   |     function transferAllowance(uint change) public {
 107 | *r  |         require(isMarried, "Not married");
 108 | *r  |         require(change > 0, "Amount must be positive");
 109 | *r  |         require(change <= taxAllowance, "Insufficient allowance");
 110 |     | 
 111 | *   |         taxAllowance -= change;
 112 | *   |         Taxpayer(spouse).receiveAllowance(change);
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Receives tax allowance from the spouse.
 117 |     |      * Can only be called by the current spouse contract.
 118 |     |      * @param amount The amount of allowance to receive.
 119 |     |      */
 120 | *   |     function receiveAllowance(uint amount) external {
 121 | *   |         require(isMarried, "Not married");
 122 | *   |         require(msg.sender == spouse, "Only spouse can transfer allowance");
 123 | *   |         taxAllowance += amount;
 124 |     |     }
 125 |     | 
 126 | *   |     function haveBirthday() public {
 127 | *   |         age++;
 128 |     | 
 129 | *   |         if (age > 64 && !hasExtendedTaxAllowance()) {
 130 | *   |             setExtendedTaxAllowance();
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 | *   |     function setTaxAllowance(uint ta) private {
 135 | *   |         taxAllowance = ta;
 136 |     |     }
 137 |     | 
 138 |     |     function getTaxAllowance() public view returns (uint) {
 139 |     |         return taxAllowance;
 140 |     |     }
 141 |     | 
 142 | *   |     function addTaxAllowance(uint ta) private {
 143 | *   |         taxAllowance = taxAllowance + ta;
 144 |     |     }
 145 |     | 
 146 | *   |     function setWonLottery() external {
 147 | *   |         require(
 148 | *   |             authorizedLotteries[msg.sender],
 149 |     |             "Only an authorized lottery can notify win"
 150 |     |         );
 151 | *   |         lotteryWins++;
 152 | *   |         setExtendedTaxAllowance();
 153 |     |     }
 154 |     | 
 155 | *   |     function setExtendedTaxAllowance() internal {
 156 | *   |         if (extendedTaxAllowance) return;
 157 | *   |         extendedTaxAllowance = true;
 158 | *   |         addTaxAllowance(ALLOWANCE_OAP - DEFAULT_ALLOWANCE);
 159 |     |     }
 160 |     | 
 161 | *   |     function hasExtendedTaxAllowance() public view returns (bool) {
 162 | *   |         return extendedTaxAllowance;
 163 |     |     }
 164 |     | 
 165 | *   |     function isMarriedState() public view returns (bool) {
 166 | *   |         return isMarried;
 167 |     |     }
 168 |     | 
 169 | *   |     function spouseAddress() public view returns (address) {
 170 | *   |         return spouse;
 171 |     |     }
 172 |     | 
 173 | *   |     function joinLottery(address lot, uint256 r) public {
 174 | *   |         Lottery lObj = Lottery(lot);
 175 |     |         // Check if it is a lottery contract
 176 | *   |         try lObj.isContract() returns (bool isLot) {
 177 | *   |             require(isLot, "Address is not a lottery contract");
 178 |     |         } catch {
 179 |     |             revert("Address does not support lottery interface");
 180 |     |         }
 181 |     | 
 182 | *   |         lObj.commit(keccak256(abi.encode(r)));
 183 | *   |         rev = r;
 184 | *   |         authorizedLotteries[lot] = true;
 185 |     |     }
 186 | *   |     function revealLottery(address lot, uint256 r) public {
 187 | *   |         Lottery lObj = Lottery(lot);
 188 | *   |         lObj.reveal(r);
 189 | *   |         rev = 0;
 190 |     |     }
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Validates if an address is suitable for contract interactions.
 194 |     |      * Checks against the null address, precompiled contracts (0x1-0x9),
 195 |     |      * the burn address (0xdEaD), and the contract's own address.
 196 |     |      * Additionally verifies that the target is a contract and a valid Taxpayer.
 197 |     |      * @param _addr The address to be validated.
 198 |     |      * @return bool True if the address is valid, false otherwise.
 199 |     |      */
 200 | *   |     function isValidSpouseAddress(address _addr) public view returns (bool) {
 201 | *   |         if (
 202 | *   |             _addr == address(0) ||
 203 | *   |             _addr == BURN_ADDRESS ||
 204 | *   |             _addr == address(this) ||
 205 | *   |             uint160(_addr) <= 9 ||
 206 | *   |             _addr.code.length == 0
 207 |     |         ) {
 208 | *   |             return false;
 209 |     |         }
 210 |     | 
 211 |     |         // Try to call isContract() to verify it is a Taxpayer contract
 212 | *   |         try Taxpayer(_addr).isContract() returns (bool isTax) {
 213 | *   |             return isTax;
 214 |     |         } catch {
 215 |     |             return false;
 216 |     |         }
 217 |     |     }
 218 |     | }
 219 |     | 

/src/echidna.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./Taxpayer.sol";
   5 |     | import "./Lottery.sol";
   6 |     | 
   7 | *r  | contract TestTaxpayer is Taxpayer {
   8 | *   |     Taxpayer public candidate;
   9 |     |     // Define lottery periods as 10 seconds per default
  10 | *   |     uint256 public period = 10;
  11 | *   |     Lottery public l = new Lottery(period);
  12 |     | 
  13 | *   |     constructor() Taxpayer(address(0x11), address(0x12)) {
  14 | *   |         candidate = new Taxpayer(address(0x13), address(0x14));
  15 |     |     }
  16 |     | 
  17 |     |     // ASSIGNMENT PART 1
  18 |     | 
  19 |     |     /** 
  20 |     |         Check if bool isMarried and spouse address are correctly set in conjunction to each other.
  21 |     |         If the taxpayer isn't married, he/she shouldn't have a spouse address and vice versa.
  22 |     |     */
  23 |     |     function echidna_state_consistency() public view returns (bool) {
  24 |     |         return isMarried == (spouse != address(0));
  25 |     |     }
  26 |     | 
  27 |     |     /** 
  28 |     |         Check for marriage symmetry.
  29 |     |         If this taxpayer is married to someone, that partner must also be married to this taxpayer.
  30 |     |     */
  31 |     |     function echidna_marriage_symmetry() public view returns (bool) {
  32 |     |         if (isMarried) {
  33 |     |             Taxpayer partner = Taxpayer(spouse);
  34 |     |             try partner.spouseAddress() returns (address partnersSpouse) {
  35 |     |                 return (partnersSpouse == address(this) &&
  36 |     |                     partner.isMarriedState());
  37 |     |             } catch {
  38 |     |                 // If the call fails, the target is either not a contract or not a valid Taxpayer object.
  39 |     |                 return false;
  40 |     |             }
  41 |     |         }
  42 |     |         return true;
  43 |     |     }
  44 |     | 
  45 |     |     /** 
  46 |     |         Check that no self-marriage occurred.
  47 |     |     */
  48 |     |     function echidna_no_self_marriage() public view returns (bool) {
  49 |     |         return spouse != address(this);
  50 |     |     }
  51 |     | 
  52 |     |     /** 
  53 |     |         Check if marriage is ever achieved. 
  54 |     |         If this test passes, it means Echidna NEVER managed to marry anyone, 
  55 |     |         making the other marriage tests (symmetry, etc.) useless.
  56 |     |     */
  57 |     |     /* function echidna_is_never_married() public view returns (bool) {
  58 |     |         return !isMarried;
  59 |     |     } */
  60 |     | 
  61 |     |     /** 
  62 |     |         Helper functions to allow Echidna to interact with a valid contract.
  63 |     |     */
  64 | *   |     function marryCandidate() public {
  65 | *   |         marry(address(candidate));
  66 |     |     }
  67 |     | 
  68 | *   |     function divorceCandidate() public {
  69 | *   |         divorce();
  70 |     |     }
  71 |     | 
  72 |     |     // ASSIGNMENT PART 2
  73 |     | 
  74 |     |     /** 
  75 |     |         Check that the tax allowance of an unmarried taxpayer under 65 who hasn't won the lottery is 5000.
  76 |     |     */
  77 |     |     function echidna_valid_tax_allowance() public view returns (bool) {
  78 |     |         if (age < 65 && !isMarriedState() && !hasExtendedTaxAllowance()) {
  79 |     |             return (getTaxAllowance() == 5000);
  80 |     |         }
  81 |     |         return true;
  82 |     |     }
  83 |     | 
  84 |     |     /** 
  85 |     |         Check that the tax allowance of an unmarried taxpayer under 65 who has won the lottery is 7000.
  86 |     |     */
  87 |     |     function echidna_valid_tax_allowance_winner() public view returns (bool) {
  88 |     |         if (age < 65 && !isMarriedState() && hasExtendedTaxAllowance()) {
  89 |     |             return (getTaxAllowance() == 7000);
  90 |     |         }
  91 |     |         return true;
  92 |     |     }
  93 |     | 
  94 |     |     /** 
  95 |     |         Check that the tax allowance of a taxpayer is never below zero.
  96 |     |     */
  97 |     |     function echidna_tax_allowance_never_lower_than_zero()
  98 |     |         public
  99 |     |         view
 100 |     |         returns (bool)
 101 |     |     {
 102 |     |         return (getTaxAllowance() >= 0);
 103 |     |     }
 104 |     | 
 105 |     |     /** 
 106 |     |         Check that the tax allowance of a married couple is either 10000,12000 or 14000.
 107 |     |     */
 108 |     |     function echidna_valid_married_tax_allowance() public view returns (bool) {
 109 |     |         if (isMarriedState()) {
 110 |     |             Taxpayer spObj = Taxpayer(spouseAddress());
 111 |     |             uint combined = getTaxAllowance() + spObj.getTaxAllowance();
 112 |     |             return (combined == 10000 ||
 113 |     |                 combined == 12000 ||
 114 |     |                 combined == 14000);
 115 |     |         }
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     // ASSIGNMENT PART 3
 120 |     | 
 121 |     |     /** 
 122 |     |         Check that the tax allowance of an unmarried taxpayer over 65 is always 7000.
 123 |     |     */
 124 |     |     function echidna_valid_tax_allowance_over_64() public view returns (bool) {
 125 |     |         if (age >= 65 && !isMarriedState()) {
 126 |     |             return (getTaxAllowance() == 7000);
 127 |     |         }
 128 |     |         return true;
 129 |     |     }
 130 |     | 
 131 |     |     /** 
 132 |     |         Check that the tax allowance of a married couple over 64 is always 14000.
 133 |     |     */
 134 |     |     function echidna_valid_married_tax_allowance_over_64()
 135 |     |         public
 136 |     |         view
 137 |     |         returns (bool)
 138 |     |     {
 139 |     |         if (isMarriedState() && age > 64) {
 140 |     |             Taxpayer spObj = Taxpayer(spouseAddress());
 141 |     |             if (spObj.age() > 64) {
 142 |     |                 uint combined = getTaxAllowance() + spObj.getTaxAllowance();
 143 |     |                 return (combined == 14000);
 144 |     |             }
 145 |     |         }
 146 |     |         return true;
 147 |     |     }
 148 |     | 
 149 |     |     /** 
 150 |     |         Helper function for echidna to advance age more quickly.
 151 |     |     */
 152 | *   |     function advanceTaxpayerAge() public {
 153 | *   |         for (uint i = 0; i < 15; i++) {
 154 | *   |             haveBirthday();
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /** 
 159 |     |         Helper function for echidna to advance age of spouse more quickly.
 160 |     |     */
 161 | *   |     function advanceTaxpayerSpouseAge() public {
 162 | *   |         for (uint i = 0; i < 15; i++) {
 163 | *r  |             Taxpayer(spouseAddress()).haveBirthday();
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     // ASSIGNMENT PART 4
 168 |     | 
 169 |     |     /** 
 170 |     |         Helper function for echidna to run lotteries.
 171 |     |     */
 172 | *   |     function startLottery() public {
 173 | *r  |         l.startLottery();
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |         Overloaded version for Echidna to use the specific test lottery.
 178 |     |     */
 179 | *   |     function joinLottery(uint256 r) public {
 180 | *   |         joinLottery(address(l), r);
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |         Parameterless reveal for Echidna. 
 185 |     |         Uses the stored value from the contract state to ensure a successful reveal.
 186 |     |     */
 187 | *   |     function revealLottery() public {
 188 | *   |         revealLottery(address(l), rev);
 189 |     |     }
 190 |     | 
 191 |     |     /**
 192 |     |         Allows the candidate taxpayer to join the same lottery.
 193 |     |     */
 194 | *   |     function joinLotteryCandidate(uint256 r) public {
 195 | *r  |         candidate.joinLottery(address(l), r);
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |         Parameterless reveal for the candidate.
 200 |     |     */
 201 | *   |     function revealLotteryCandidate() public {
 202 | *r  |         candidate.revealLottery(address(l), candidate.rev());
 203 |     |     }
 204 |     | 
 205 |     |     /** 
 206 |     |         Helper function for echidna to end lotteries.
 207 |     |     */
 208 | *   |     function endLottery() public {
 209 | *r  |         l.endLottery();
 210 |     |     }
 211 |     | 
 212 |     |     /** 
 213 |     |         Check that all participants in the lottery are valid Taxpayer contracts.
 214 |     |         This prevents crashes during the winner notification call.
 215 |     |     */
 216 |     |     function echidna_lottery_participants_valid() public view returns (bool) {
 217 |     |         address[] memory revList = l.getRevealedParticipants();
 218 |     |         for (uint i = 0; i < revList.length; i++) {
 219 |     |             if (revList[i].code.length == 0) return false;
 220 |     |             try Taxpayer(revList[i]).isContract() returns (bool isTax) {
 221 |     |                 if (!isTax) return false;
 222 |     |             } catch {
 223 |     |                 return false;
 224 |     |             }
 225 |     |         }
 226 |     |         return true;
 227 |     |     }
 228 |     | 
 229 |     |     /** 
 230 |     |         Check for honest behavior: A participant should not be in the revealed list multiple times.
 231 |     |         Duplicates bias the winning probability (total % n).
 232 |     |     */
 233 |     |     function echidna_lottery_no_duplicates() public view returns (bool) {
 234 |     |         address[] memory revList = l.getRevealedParticipants();
 235 |     |         for (uint i = 0; i < revList.length; i++) {
 236 |     |             for (uint j = i + 1; j < revList.length; j++) {
 237 |     |                 if (revList[i] == revList[j]) return false;
 238 |     |             }
 239 |     |         }
 240 |     |         return true;
 241 |     |     }
 242 |     | 
 243 |     |     /** 
 244 |     |         Check that the lottery is unbiased over many rounds.
 245 |     |         In a fair lottery with two equal participants (this and candidate), 
 246 |     |         the win count difference should not grow excessively large.
 247 |     |     */
 248 |     |     function echidna_lottery_fairness() public view returns (bool) {
 249 |     |         uint256 w1 = lotteryWins;
 250 |     |         uint256 w2 = candidate.lotteryWins();
 251 |     |         
 252 |     |         // After at least some lotteries have been won
 253 |     |         if (w1 + w2 > 10) {
 254 |     |             uint256 diff = w1 > w2 ? w1 - w2 : w2 - w1;
 255 |     |             // A difference of more than 80% of total wins indicates high bias 
 256 |     |             return (diff * 10 < (w1 + w2) * 8); 
 257 |     |         }
 258 |     |         return true;
 259 |     |     }
 260 |     | }
 261 |     | 

